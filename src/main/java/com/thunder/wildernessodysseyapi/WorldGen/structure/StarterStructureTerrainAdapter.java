package com.thunder.wildernessodysseyapi.WorldGen.structure;

import com.thunder.wildernessodysseyapi.Core.ModConstants;
import com.thunder.wildernessodysseyapi.WorldGen.blocks.TerrainReplacerBlock;
import com.thunder.wildernessodysseyapi.WorldGen.configurable.StructureConfig;
import com.thunder.wildernessodysseyapi.WorldGen.util.DeferredTaskScheduler;
import net.minecraft.core.BlockPos;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.state.BlockState;

import java.util.ArrayList;
import java.util.List;

/**
 * Applies Wilderness Odyssey's terrain replacer workflow to structures generated by
 * Serilum's Starter Structure mod once the bunker is placed.
 */
public final class StarterStructureTerrainAdapter {
    private StarterStructureTerrainAdapter() {
    }

    /**
     * Schedule post-processing for the starter structure to replace marker blocks with sampled terrain.
     */
    public static void scheduleTerrainReplacement(ServerLevel level, BlockPos structureOrigin) {
        if (!StructureConfig.ENABLE_TERRAIN_REPLACER.get()) {
            return;
        }
        if (!StructureConfig.ENABLE_STARTER_STRUCTURE_TERRAIN_REPLACER.get()) {
            return;
        }
        if (structureOrigin == null) {
            return;
        }

        int delayTicks = StructureConfig.STARTER_STRUCTURE_DELAY_TICKS.get();
        DeferredTaskScheduler.schedule(level, () -> applyTerrainReplacement(level, structureOrigin), delayTicks);
    }

    private static void applyTerrainReplacement(ServerLevel level, BlockPos origin) {
        Block terrainMarker = TerrainReplacerBlock.TERRAIN_REPLACER.get();
        int horizontalRadius = Math.max(1, StructureConfig.STARTER_STRUCTURE_SCAN_RADIUS.get());
        int verticalRadius = Math.max(1, StructureConfig.STARTER_STRUCTURE_SCAN_HEIGHT.get());

        BlockPos min = origin.offset(-horizontalRadius, -verticalRadius, -horizontalRadius);
        BlockPos max = origin.offset(horizontalRadius, verticalRadius, horizontalRadius);

        List<BlockPos> markers = new ArrayList<>();
        for (BlockPos pos : BlockPos.betweenClosed(min, max)) {
            if (level.getBlockState(pos).is(terrainMarker)) {
                markers.add(pos.immutable());
            }
        }

        if (markers.isEmpty()) {
            if (StructureConfig.DEBUG_LOG_PLACEMENTS.get()) {
                ModConstants.LOGGER.debug(
                        "Starter structure near {} has no terrain replacer markers within {}h/{}v search radius.",
                        origin, horizontalRadius, verticalRadius);
            }
            return;
        }

        int replaced = 0;
        for (BlockPos markerPos : markers) {
            BlockState replacement = TerrainReplacerEngine.sampleSurfaceBlock(level, markerPos);
            level.setBlock(markerPos, replacement, 2);
            replaced++;
        }

        ModConstants.LOGGER.info(
                "Applied terrain replacer to {} marker blocks for starter structure near {} (radius {} / height {}).",
                replaced, origin, horizontalRadius, verticalRadius);
    }
}
